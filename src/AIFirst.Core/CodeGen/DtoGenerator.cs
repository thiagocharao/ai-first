using System.Text;
using AIFirst.Core.Schema;

namespace AIFirst.Core.CodeGen;

/// <summary>
/// Generates C# DTO records from JSON Schemas.
/// </summary>
public static class DtoGenerator
{
    /// <summary>
    /// Generates a C# record from a JSON Schema.
    /// </summary>
    /// <param name="schema">The JSON Schema.</param>
    /// <param name="typeName">The name for the generated type.</param>
    /// <param name="namespaceName">The namespace for the generated code.</param>
    /// <returns>Generated C# code.</returns>
    public static string GenerateRecord(JsonSchema schema, string typeName, string namespaceName = "Generated")
    {
        var sb = new StringBuilder();
        var nestedTypes = new List<string>();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();

        GenerateRecordInternal(sb, schema, typeName, nestedTypes, 0);

        // Append nested types
        foreach (var nested in nestedTypes)
        {
            sb.AppendLine();
            sb.Append(nested);
        }

        return sb.ToString();
    }

    /// <summary>
    /// Generates C# records from a tool manifest.
    /// </summary>
    /// <param name="tools">The tool contracts with schemas.</param>
    /// <param name="namespaceName">The namespace for the generated code.</param>
    /// <returns>Generated C# code.</returns>
    public static string GenerateFromTools(IEnumerable<ToolContract> tools, string namespaceName = "Generated")
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();

        foreach (var tool in tools)
        {
            if (!string.IsNullOrEmpty(tool.ParametersSchemaJson) && tool.ParametersSchemaJson != "{}")
            {
                var schema = JsonSchemaParser.Parse(tool.ParametersSchemaJson);
                var typeName = CSharpTypeMapper.ToPascalCase(tool.Name) + "Request";
                var nestedTypes = new List<string>();

                GenerateRecordInternal(sb, schema, typeName, nestedTypes, 0);
                sb.AppendLine();

                foreach (var nested in nestedTypes)
                {
                    sb.AppendLine(nested);
                }
            }
        }

        return sb.ToString();
    }

    private static void GenerateRecordInternal(
        StringBuilder sb, 
        JsonSchema schema, 
        string typeName, 
        List<string> nestedTypes,
        int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);

        // Add XML doc comment
        if (!string.IsNullOrEmpty(schema.Description))
        {
            sb.AppendLine(indent + "/// <summary>");
            sb.AppendLine(indent + "/// " + EscapeXml(schema.Description));
            sb.AppendLine(indent + "/// </summary>");
        }

        // Start record definition
        sb.Append(indent + "public sealed record " + typeName + "(");

        var properties = schema.Properties.ToList();
        if (properties.Count == 0)
        {
            sb.AppendLine(");");
            return;
        }

        sb.AppendLine();

        for (var i = 0; i < properties.Count; i++)
        {
            var (name, propSchema) = properties[i];
            var isRequired = schema.Required.Contains(name);
            var isLast = i == properties.Count - 1;

            // Handle nested objects
            var csharpType = GetPropertyType(propSchema, name, nestedTypes, typeName);

            // Add nullability for optional properties
            if (!isRequired && !csharpType.EndsWith("?") && !IsReferenceType(csharpType))
            {
                csharpType += "?";
            }

            var paramName = CSharpTypeMapper.ToPascalCase(name);

            // Add property doc comment
            if (!string.IsNullOrEmpty(propSchema.Description))
            {
                sb.AppendLine(indent + "    /// <summary>" + EscapeXml(propSchema.Description) + "</summary>");
            }

            sb.Append(indent + "    " + csharpType + " " + paramName);

            // Add default value for optional properties
            if (!isRequired)
            {
                sb.Append(" = default");
            }

            if (!isLast)
            {
                sb.AppendLine(",");
            }
            else
            {
                sb.AppendLine(");");
            }
        }
    }

    private static string GetPropertyType(JsonSchema schema, string propertyName, List<string> nestedTypes, string parentTypeName)
    {
        // Handle nested objects
        if (schema.Type == "object" && schema.Properties.Count > 0 && string.IsNullOrEmpty(schema.Title))
        {
            var nestedTypeName = parentTypeName + CSharpTypeMapper.ToPascalCase(propertyName);
            var nestedSb = new StringBuilder();
            GenerateRecordInternal(nestedSb, schema, nestedTypeName, nestedTypes, 0);
            nestedTypes.Add(nestedSb.ToString());
            return nestedTypeName;
        }

        // Handle arrays of objects
        if (schema.Type == "array" && schema.Items?.Type == "object" && schema.Items.Properties.Count > 0)
        {
            var itemTypeName = parentTypeName + CSharpTypeMapper.ToPascalCase(propertyName) + "Item";
            var nestedSb = new StringBuilder();
            GenerateRecordInternal(nestedSb, schema.Items, itemTypeName, nestedTypes, 0);
            nestedTypes.Add(nestedSb.ToString());
            return "IReadOnlyList<" + itemTypeName + ">";
        }

        return CSharpTypeMapper.MapToCSharpType(schema, propertyName);
    }

    private static bool IsReferenceType(string typeName)
    {
        return typeName switch
        {
            "string" => true,
            "object" => true,
            _ when typeName.StartsWith("IReadOnly") => true,
            _ => false
        };
    }

    private static string EscapeXml(string text)
    {
        return text
            .Replace("&", "&amp;")
            .Replace("<", "&lt;")
            .Replace(">", "&gt;");
    }
}
